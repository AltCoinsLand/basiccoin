import time, copy, custom, tools, stackDB, networking, transactions
#this file explains how we talk to the database. It explains the rules for adding blocks and transactions.
def db_get (n, DB): 
    n=str(n)
    if len(n)==130: n=tools.pub2addr(n)
    try:
        a=DB['db'].Get(n)
    except:
        error('here')
    return tools.unpackage(a)
def db_put(key, dic, DB):  
    key=str(key)
    if len(key)==130: key=tools.pub2addr(key)
    return DB['db'].Put(key, tools.package(dic))
def db_delete(key, DB): return DB['db'].Delete(str(key))
def count(pubkey, DB):
    def zeroth_confirmation_txs(pubkey, DB):
        c=0
        try:
            txs=DB['txs']
        except:
            DB['txs']=[]
            return 0
        for t in txs:
            if pubkey==t['id']:
                c+=1
        return c
    def current(pubkey, DB):
        try:
            acc=db_get(pubkey, DB)
        except:
            acc={'count':0, 'amount':0}
            db_put(pubkey, acc, DB)
        if 'count' not in acc:
            acc['count']=0
            db_put(pubkey, acc, DB)
        return acc['count']
    return current(pubkey, DB)+zeroth_confirmation_txs(pubkey, DB)
def add_tx(tx, DB):
    tx_check=transactions.tx_check
    def verify_count(tx, txs): return tx['count']!=count(tx['id'], DB)
    def type_check(tx, txs): return type(tx) != type({'a':1}) or 'type' not in tx or tx['type'] not in tx_check
    def too_big_block(tx, txs): return len(tools.package(txs+[tx]))>networking.MAX_MESSAGE_SIZE-5000
    def verify_tx(tx, txs):
        if type_check(tx, txs): return False
        if verify_count(tx, txs): return False
        if too_big_block(tx, txs): return False
        return tx_check[tx['type']](tx, txs, DB)
    if verify_tx(tx, DB['txs']): DB['txs'].append(tx)
targets={}
times={}#stores blocktimes
def recent_blockthings(key, DB, size=100, length=0):
    if key=='time': storage=times
    if key=='target': storage=targets
    def get_val(length):
        leng=str(length)
        if not leng in storage: storage[leng]=db_get(leng, DB)[key]
        return storage[leng]
    if length==0: length=DB['length']
    start= (length-size) if (length-size)>=0 else 0
    return map(get_val, range(start, length))
def target(DB, length=0):
    inflection=0.985#This constant is selected such that the 50 most recent blocks count for 1/2 the total weight.
    history_length=400#How far back in history do we compute the target from.
    if length==0: length=DB['length']
    if length<4: return '0'*4+'f'*60#use same difficulty for first few blocks.
    if length<=DB['length']: return targets[str(length)]#don't calculate same difficulty twice.
    def buffer(str):
        if len(str)<64: return buffer('0'+str)
        return str
    def targetTimesFloat(target, number): return buffer(str(hex(int(int(target, 16)*number)))[2:-1])
    def weights(length): return [inflection**(length-i) for i in range(length)]
    def estimate_target(DB):
        def invertTarget(n): return buffer(str(hex(int('f'*128, 16)/int(n, 16)))[2:-1])#use double-size for division, to reduce information leakage.
        def sumTargets(l):
            def plus(a, b): return buffer(str(hex(int(a, 16)+int(b, 16)))[2:-1])
            if len(l)<1: return 0
            while len(l)>1:
                l=[plus(l[0], l[1])]+l[2:]
            return l[0]
        targets=recent_blockthings('target', DB, history_length)        
        w=weights(len(targets))
        tw=sum(w)
        targets=map(invertTarget, targets)#invert because target is proportional to 1/(# hashes required to mine a block on average)
        weighted_targets=[targetTimesFloat(targets[i], w[i]/tw) for i in range(len(targets))]
        return invertTarget(sumTargets(weighted_targets))#invert again to fix units
    def estimate_time(DB):
        timestamps=recent_blockthings('time', DB, history_length)
        blocklengths=[timestamps[i]-timestamps[i-1] for i in range(1, len(timestamps))]
        w=weights(len(blocklengths))#geometric weighting
        tw=sum(w)#normalization constant
        return sum([w[i]*blocklengths[i]/tw for i in range(len(blocklengths))])
    return targetTimesFloat(estimate_target(DB), estimate_time(DB)/custom.blocktime(length))
def add_block(block, DB):
    def median(mylist): #median is good for weeding out liars, so long as the liars don't have 51% hashpower.
        if len(mylist)<1: return 0
        return sorted(mylist)[len(mylist) / 2]
    def block_check(block, DB):
        earliest=median(recent_blockthings('time', DB))
        length=copy.deepcopy(DB['length'])
        if 'error' in block.keys(): return False
        if type(block)!=type({'a':1}): return False
        if int(block['length'])!=int(length)+1: return False
        if length >=0 and tools.det_hash(db_get(length, DB))!=block['prevHash']: return False
        a=copy.deepcopy(block)
        a.pop('nonce')
        if u'target' not in block.keys() or tools.det_hash({u'nonce':block['nonce'], u'halfHash':tools.det_hash(a)})>block['target'] or block['target']!=target(DB, block['length']): return False
        if 'time' not in block or block['time']>time.time() or block['time']<earliest: return False
        return True
    if block_check(block, DB):
        print('add_block: '+str(block))
        db_put(block['length'], block, DB)
        DB['length']=block['length']
        orphans=DB['txs']
        DB['txs']=[]
        for tx in block['txs']:
            transactions.update[tx['type']](tx, DB)
        for tx in orphans:
            add_tx(tx, DB)
def delete_block(DB):
    if DB['length']<0: return
    try:
        targets.pop(str(length))
        times.pop(str(length))
    except:
        pass
    block=db_get(DB['length'], DB)
    orphans=DB['txs']
    DB['txs']=[]
    for tx in block['txs']:
        orphans.append(tx)
        transactions.downdate[tx['type']](tx, DB)
    db_delete(DB['length'], DB)
    DB['length']-=1
    for orphan in sorted(orphans, key=lambda x: x['count']):
        add_tx(tx, DB)
import blockchain, custom, tools, networking, stackDB, random, time, copy
#This file mines blocks and talks to peers. It maintains consensus of the blockchain.
def mine(hashes_till_check, reward_address, DB):
    def make_mint(pubkey, DB): return {'type':'mint', 'id':pubkey, 'count':blockchain.count(pubkey, DB)}
    def genesis(pubkey, DB):
        out={'version':custom.version,
             'length':0,
             'time':time.time(),
             'target':blockchain.target(DB),
             'txs':[make_mint(pubkey, DB)]}
        out=tools.unpackage(tools.package(out))
        return out
    def make_block(prev_block, txs, pubkey, DB):
        leng=int(prev_block['length'])+1
        out={'version':custom.version,
             'txs':txs+[make_mint(pubkey, DB)],
             'length':leng,
             'time':time.time(),
             'target':blockchain.target(DB, leng),
             'prevHash':tools.det_hash(prev_block)}
        out=tools.unpackage(tools.package(out))
        return out
    def POW(block, hashes, target):
        halfHash=tools.det_hash(block)
        block[u'nonce']=random.randint(0,100000000000000000)
        count=0
        while tools.det_hash({u'nonce':block['nonce'], u'halfHash':halfHash})>target:
            count+=1
            block[u'nonce']+=1
            if count>hashes:
                return {'error':False}
            ''' for testing sudden loss in hashpower from miners.
            if block[u'length']>150:# and block[u'nonce']%10==0: time.sleep(0.1)
            else: time.sleep(0.01)
            '''
        return block
    length=copy.deepcopy(DB['length'])
    if length==-1:
        block=genesis(reward_address, DB)
        txs=[]
    else:
        prev_block=blockchain.db_get(length, DB)
        txs=DB['txs']
        block=make_block(prev_block, txs, reward_address, DB)
    block=POW(block, hashes_till_check, blockchain.target(DB, block['length']))
    stackDB.push('suggested_blocks.db', block)
def peers_check(peers, DB):
    def fork_check(newblocks, DB):
        #if we are on a fork, return True
        try:
            length=copy.deepcopy(DB['length'])
            block=blockchain.db_get(length, DB)
            recent_hash=tools.det_hash(block)
            return recent_hash not in map(tools.det_hash, newblocks)
        except Exception as e:
            #print('ERROR: ' +str(e))
            return False
    def peer_check(peer, DB):
        cmd=(lambda x: networking.send_command(peer, x))
        block_count=cmd({'type':'blockCount'})
        if type(block_count)!=type({'a':1}):
            return 
        if 'error' in block_count.keys():
            return         
        length=copy.deepcopy(DB['length'])
        ahead=int(block_count['length'])-length
        if ahead < 0:#if we are ahead of them
            cmd({'type':'pushblock', 'block':blockchain.db_get(block_count['length']+1, DB)})
            return []
        if ahead == 0:#if we are on the same block, ask for any new txs
            block=blockchain.db_get(length, DB)
            if 'recent_hash' in block_count and tools.det_hash(block)!=block_count['recent_hash']:
                blockchain.delete_block()
                #print('WE WERE ON A FORK. time to back up.')
                return []
            my_txs=DB['txs']
            txs=cmd({'type':'txs'})
            for tx in txs:
                stackDB.push('suggested_txs.db', tx)
            pushers=[x for x in my_txs if x not in txs]
            for push in pushers:
                cmd({'type':'pushtx', 'tx':push})
            return []
        start=length-30
        if start<0:
            start=0
        if ahead>500:
            end=length+499
        else:
            end=block_count['length']
        blocks= cmd({'type':'rangeRequest', 
                     'range':[start, end]})
        if type(blocks)!=type([1,2]):
            return []
        times=2
        while fork_check(blocks, DB) and times>0:
            times-=1
            blockchain.delete_block(DB)
        for block in blocks:
            stackDB.push('suggested_blocks.db', block)
    for peer in peers:
        peer_check(peer, DB)
def suggestions(DB):
    def file_map(func, file):
        things=stackDB.load(file)
        stackDB.reset(file)
        [func(x, DB) for x in things]
    map(file_map, [blockchain.add_tx, blockchain.add_block], ['suggested_txs.db', 'suggested_blocks.db'])
    stackDB.reset('suggested_blocks.db')
    stackDB.reset('suggested_txs.db')
def mainloop(reward_address, peers, hashes_till_check, DB):
    while True:
        mine(hashes_till_check, reward_address, DB) 
        peers_check(peers, DB)
        suggestions(DB)


import pt
#This is for easy customization of new currencies.
database_name='DB.db'
listen_port=8900
gui_port=8700
version="VERSION"
block_reward=10**5
premine=5*10**6
fee=10**3
brainwallet='brain wallet'
privkey=pt.sha256(brainwallet)
pubkey=pt.privtopub(privkey)
peers=[['localhost', 8901],['localhost', 8902],['localhost', 8903],['localhost', 8904],['localhost', 8905]]
hashes_per_check=10**5
def blocktime(length):
    if length*block_reward<premine:
        return 30#I can't get the blocks to come much quicker than 3. This needs to be optimized badly.
    else:
        return 60

#from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
#import string, cgi, time, networking, stackDB, copy, tools, pt
import networking, stackDB, copy, tools, pt, os, blockchain, custom, http
DEFAULT_BRAIN=''#so that you don't have to type it in every time.
def spend(amount, pubkey, privkey, to_pubkey, DB):
    amount=int(amount*(10**5))
    tx={'type':'spend', 'id':pubkey, 'amount':amount, 'to':to_pubkey}
    easy_add_transaction(tx, privkey, DB)
def easy_add_transaction(tx_orig, privkey, DB):
    tx=copy.deepcopy(tx_orig)
    pubkey=pt.privtopub(privkey)
    try:
        tx['count']=blockchain.count(pubkey, DB)
    except:
        tx['count']=1
    tx['signature']=pt.ecdsa_sign(tools.det_hash(tx), privkey)
    blockchain.add_tx(tx, DB)
submit_form='''
<form name="first" action="{}" method="{}">
<input type="submit" value="{}">{}
</form> {}
'''
def easyForm(link, button_says, moreHtml='', typee='post'):
    a=submit_form.format(link, '{}', button_says, moreHtml, "{}")
    if typee=='get':
        return a.format('get', '{}')
    else:
        return a.format('post', '{}')
linkHome = easyForm('/', 'HOME', '', 'get')
def page1(brainwallet=DEFAULT_BRAIN):
    out=empty_page
    out=out.format(easyForm('/home', 'Play Go!', '<input type="text" name="BrainWallet" value="{}">'.format(brainwallet)))
    return out.format('')
def home(dic, DB):
    if 'BrainWallet' in dic:
        dic['privkey']=pt.sha256(dic['BrainWallet'])
    elif 'privkey' not in dic:
        return "<p>You didn't type in your brain wallet.</p>"
    privkey=dic['privkey']
    pubkey=pt.privtopub(dic['privkey'])
    if 'do' in dic.keys():
        if dic['do']=='spend':
            spend(float(dic['amount']), pubkey, privkey, dic['to'], DB)
    out=empty_page
    out=out.format('<p>your address is: ' +str(tools.pub2addr(pubkey))+'</p>{}')
    out=out.format('<p>current block is: ' +str(DB['length'])+'</p>{}')
    try:
        balance=blockchain.db_get(pubkey, DB)
        balance=balance['amount']
    except:
        balance=0
    for tx in DB['txs']:
        if tx['type'] == 'spend' and tx['to'] == tools.pub2addr(pubkey):
            balance += tx['amount']
        if tx['type'] == 'spend' and tx['id'] == pubkey:
            balance -= tx['amount']
    out=out.format('<p>current balance is: ' +str(balance/100000.0)+'</p>{}')
    if balance>0:
        out=out.format(easyForm('/home', 'spend money', '''
        <input type="hidden" name="do" value="spend">
        <input type="text" name="to" value="address to give to">
        <input type="text" name="amount" value="amount to spend">
        <input type="hidden" name="privkey" value="{}">'''.format(privkey)))    
    s=easyForm('/home', 'Refresh', '''    <input type="hidden" name="privkey" value="{}">'''.format(privkey))
    return out.format(s)
def hex2htmlPicture(string, size):
    return '<img height="{}" src="data:image/png;base64,{}">{}'.format(str(size), string, '{}')
empty_page='<html><body>{}</body></html>'
def txt2src(txt):
    return "data:image/png;base64,"+txt
def main(port, brain_wallet, db):
    global DEFAULT_BRAIN
    global DB
    DEFAULT_BRAIN = brain_wallet
    DB = db
    ip = ''
    http.serve('localhost', port)
from Yashttpd import serve_forever, CHUNK, CONQ
from urlparse import parse_qs
from mimetypes import guess_type


def GET(request_dict):
    path = request_dict['uri'][1:]
    if path == '':
        message = page1(DEFAULT_BRAIN)
        return {'code':'200', 'message':message, 'headers':{'Content-Type':'text/html', 'Content-Length':str(len(message))}}
    path = os.path.join(os.getcwd(), path)
    if not os.path.exists(path): return {'code':'404'} #not found
    typ_, encoding = guess_type(path)
    f = open(path)
    message = f.read()
    f.close()
    headers = {'Content-Type':typ_, 'Content-Length':str(len(message))}
    if encoding: headers.update({'Content-Encoding':encoding})
    return {'code':'200', 'message':message, 'headers':headers}

def POST(request_dict):
    path = request_dict['uri']
    if path != '/home': return {'code':'404'}
    field_info = parse_qs(request_dict['message'])
    fixes = ({key:val[0]} if len(val)>0 else {key:''} for key, val in field_info.items()) #generator
    for fix in fixes: field_info.update(fix)
    message = home(field_info, DB)
    return {'code':'200', 'message':message, 'headers':{'Content-Type':'text/html', 'Content-Length':str(len(message))}}

def handler(request_dict):
    method = request_dict['method']
    if method == 'GET': return GET(request_dict)
    if method == 'POST': return POST(request_dict)
    return {'code':'501'} #method not implemented

def serve(ip, port): return serve_forever(ip, port, CONQ, CHUNK, handler)
import networking, custom, stackDB, tools, leveldb, shutil, time, blockchain
#Sometimes peers ask us for infomation or push new info to us. This file explains how we respond.
def main(dic, DB):
    def security_check(dic):
        if 'version' not in dic or dic['version']!=custom.version:
            return {'bool':False, 'error':'version'}
        else:
            #we could add security freatures here.
            return {'bool':True, 'newdic':dic}
    def blockCount(dic, DB):
        length=DB['length']
        if length>0:
            return {'length':length, 'prevHash':DB['recentHash'], 'sig_length':0}
        else:
            return {'length':0, 'prevHash':0, 'sig_length':0}
    def rangeRequest(dic, DB):
        #print('Range Request: '+str(dic))
        ran=dic['range']
        out=[]
        counter=0
        while len(tools.package(out))<50000 and ran[0]+counter<=ran[1]:
            block=blockchain.db_get(ran[0]+counter, DB)
            if 'length' in block:
                out.append(block)
            counter+=1
        return out
    def txs(dic, DB): return DB['txs']
    def pushtx(dic, DB): 
        #print('PUSHTX')
        stackDB.push('suggested_txs.db', dic['tx'])
        return 'success'
    def pushblock(dic, DB):
        stackDB.push('suggested_blocks.db', dic['block'])
        return 'success'
    funcs={'blockCount':blockCount, 'rangeRequest':rangeRequest, 'txs':txs, 'pushtx':pushtx, 'pushblock':pushblock}
    if dic['type'] not in funcs.keys():
        return str(dic['type'])+' is not in the api'
    check=security_check(dic)
    if not check['bool']:
        return check
    try:
        return funcs[dic['type']](check['newdic'], DB)
    except:
        pass
        #print('LISTENER ERROR. CONTINUING')
def server(DB): return networking.serve_forever(main, custom.listen_port, DB)

import socket, subprocess, re, tools, custom, time
#this file explains how sockets work for networking.
MAX_MESSAGE_SIZE = 60000
def kill_processes_using_ports(ports):
    popen = subprocess.Popen(['netstat', '-lpn'],
                             shell=False,
                             stdout=subprocess.PIPE)
    (data, err) = popen.communicate()
    pattern = "^tcp.*((?:{0})).* (?P<pid>[0-9]*)/.*$"
    pattern = pattern.format(')|(?:'.join(ports))
    prog = re.compile(pattern)
    for line in data.split('\n'):
        match = re.match(prog, line)
        if match:
            pid = match.group('pid')
            subprocess.Popen(['kill', '-9', pid])
def serve_forever(message_handler_func, PORT, queue):
    server = socket.socket()
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('127.0.0.1', PORT))
    server.listen(100)
    while True:
        client, addr = server.accept()
        (ip, port) = addr
        data = client.recv(MAX_MESSAGE_SIZE)
        #we could insert security checks here
        data=tools.unpackage(data)
        client.send(tools.package(message_handler_func(data, queue)))
def connect(msg, host, port):
    if len(msg)<1 or len(msg)>MAX_MESSAGE_SIZE:
        print('wrong sized message')
        return
    s = socket.socket()
    try:
        s.settimeout(2)
        s.connect((str(host), int(port)))
        msg['version']=custom.version
        s.send(tools.package(msg))
        response = s.recv(MAX_MESSAGE_SIZE)
        #print(response)
        return tools.unpackage(response)
    except Exception as e:
        #print('THE ERROR WAS: ' +str(e))
        #print('disconnect')
        return {'error':'error'}
def send_command(peer, msg): return connect(msg, peer[0], peer[1])
import json
def load(file):#keep
    def line2dic(line):
        return json.loads(line.strip('\n'))
    out=[]
    try:
        with open(file, 'rb') as myfile:
            a=myfile.readlines()
            for i in a:
                out.append(line2dic(i))
    except:
        pass
    return out
def push(file, x):#keep
    with open(file, 'a') as myfile:
        myfile.write(json.dumps(x)+'\n')
def reset(file): return open(file, 'w').close()#keep
import consensus, listener, threading, custom, blockchain, leveldb, gui, networking
db=leveldb.LevelDB(custom.database_name)
DB={'db':db, 'recentHash':0, 'length':-1, 'sigLength':-1, 'txs':[]}
todo=[[consensus.mainloop, (custom.pubkey, custom.peers, custom.hashes_per_check, DB), False],
      [listener.server, (DB, ), False],
      [gui.main, (custom.gui_port, custom.brainwallet, DB), False]]
networking.kill_processes_using_ports([str(custom.gui_port),str(custom.listen_port)])
for i in todo:
    t = threading.Thread(target=i[0], args = i[1])
    t.setDaemon(i[2])
    t.start()
import hashlib, pt
from json import dumps as package, loads as unpackage
#def pub2addr(x): return 'Z'+x[0:32]
def pub2addr(x): return pt.pubtoaddr(x)
def det_hash(x):#deterministically hash
    def det(x): return {list: (lambda l: '[%s]' % ','.join(map(det, sorted(l)))),
                        dict:(lambda x: '{%s}' % ','.join(map(lambda p: det(p[0]) + ':' + det(p[1]), sorted(x.items()))))}.get(type(x), str)(x)
    return hashlib.sha256(det(unpackage(package(x)))).hexdigest()
import blockchain, custom, copy, tools, pt
#This file explains how we tell if a transaction is valid or not, it explains how we update the system when new transactions are added to the blockchain.
def spend_verify(tx, txs, DB): 
    tx_copy=copy.copy(tx)
    tx_copy.pop('signature')
    if not pt.ecdsa_verify(tools.det_hash(tx_copy), tx['signature'], tx['id']): return False
    if tx['amount']<custom.fee: return False
    if int(blockchain.db_get(tx['id'], DB)['amount'])<int(tx['amount']): return False
    return True
def mint_verify(tx, txs, DB):
    for t in txs: 
        if t['type']=='mint': return False 
    return True
tx_check={'spend':spend_verify, 'mint':mint_verify}
def adjust_amount(pubkey, amount, DB):
    try:
        acc=blockchain.db_get(pubkey, DB)
    except:
        blockchain.db_put(pubkey, {'amount': amount}, DB)
        return
    if 'amount' not in acc: acc['amount']=amount
    else: acc['amount']+=amount
    blockchain.db_put(pubkey, acc, DB)        
def adjust_count(pubkey, DB, upward=True):
    try:
        acc=blockchain.db_get(pubkey, DB)
    except:
        blockchain.db_put(pubkey, {'count': 1}, DB)
        return
    if 'count' not in acc: acc['count']=0
    if upward: acc['count']+=1
    else: acc['count']-=1
    blockchain.db_put(pubkey, acc, DB)
def mint(tx, DB):
    adjust_amount(tx['id'], custom.block_reward, DB)
    adjust_count(tx['id'], DB)
def spend(tx, DB):
    adjust_amount(tx['id'], -tx['amount'], DB)
    adjust_amount(tx['to'], tx['amount']-custom.fee, DB)
    adjust_count(tx['id'], DB)
update={'mint':mint, 'spend':spend}
def unmint(tx, DB):
    adjust_amount(tx['id'], -custom.block_reward, DB)
    adjust_count(tx['id'], DB, False)
def unspend(tx, DB):
    adjust_amount(tx['id'], tx['amount'], DB)
    adjust_amount(tx['to'], custom.fee-tx['amount'], DB)
    adjust_count(tx['id'], DB, False)
downdate={'mint':unmint, 'spend':unspend}
